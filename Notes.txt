

# Create more difficult dataset from basic synthetic manifolds.
# Union hypersphere and hypercube.
# The idea is to be confident that the ID estimators work well on complex datasets.

# explore properties of knn graph. what is the highest degree node?
# is the sum of sssp distances smaller for nodes that are in more dense areas?
# if we uniformly randomly choose nodes to compute sssp for, then we are more likely to choose nodes from highly dense
# areas.

# minimizing K makes sure that any path in the graph represents a smooth interpolation between points?

# given the shortest distances from u to all other nodes, we have that the shortest distance from v to any node r
# is less than (dvu + minDist(u,r)). However, minDist(u,r) may be large and so computing sssp on v may give a much
# better approximation to minDist(v,r). Maybe we can eliminate some computation by assuming that for the KNNs of u,
# their contribution to the pdf is not very important given u's contribution.
# willing to bet that for some unbounded quality measure, the quality of approximation grows logarithmically with
# sample size

# if u,v are nn then the distances of u,v bound eachother. If u,v are close then calculating sssp for both u and v is
# basically redundant.














# Changes the MST weight should NOT increase across iterations.
# If it does then this may be due to non commutativity of floating point addition? or maybe because I shuffle the data

# MNIST
# exact = 14957.282871772331
# approx = 14957.302264034748

# LFW
# exact = 9100.169333803324
# approx = 9100.26 using k=25 and 9100.21 for k=39
# approx remains 9100.211251 ... for k from 39 to 65
# at k = 66 we get ~9100.16966 and stay here through 99

# ImageNet
# approx =
# 3118154.5337726837
# 3118152.810012079
# 3118151.925573564
# 3118148.537595964
# 3118147.0783071285
# 3118147.078305221
# 3118147.078303314
# 3118147.078300453
# 3118147.078297592
# 3118147.0782956844
# ...
# 3118147.0783021217 for  k = 92







  # import ngtpy
  # if not os.path.exists('../datasets/MNIST/KnnIndex'):
  #   print('creating index')
  #   ngtpy.create(path='../datasets/MNIST/KnnIndex', dimension=784, edge_size_for_creation=k, edge_size_for_search=k)
  #   index = ngtpy.Index('../datasets/MNIST/KnnIndex') # open the index
  #   for x in tqdm(xb):
  #     index.insert(x.tolist())
  #   print('Building Index')
  #   index.build_index() # build index
  #   print('Saving Index')
  #   index.save() # save the index
  #   print('Done!')
  # else:
  #   index = ngtpy.Index('../datasets/MNIST/KnnIndex') # open the index
  # print('Creating knn graph')
  # graph = {}
  # for i,x in tqdm(enumerate(xb)):
  #   result = index.search(x.tolist(), k+1)
  #   neighbors = []
  #   for rank,(id,pdfMaxDist) in enumerate(result):
  #     if id == i:
  #       continue
  #     neighbors.append((id,pdfMaxDist))
  #   graph[i] = neighbors[:k]
  # print('Done!')
  # return graph
